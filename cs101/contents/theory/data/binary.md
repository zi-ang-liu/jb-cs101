# 2進法

## ２進加算

$$
\begin{array}{r}
  58 \\
+ 27 \\
\hline
  85 \\
\end{array}
$$

$$
\begin{array}{r}
  111010 \\
+ 11011 \\
\hline
  1010101 \\
\end{array}
$$

## ２の補数記法

２の補数(two's complement)記法は、コンピュータで整数を表現する最も一般的な体系である。

長さ３のパターン

| ビットパターン | 表現する値 |
| -------------- | ---------- |
| 011            | 3          |
| 010            | 2          |
| 001            | 1          |
| 000            | 0          |
| 111            | -1         |
| 110            | -2         |
| 101            | -3         |
| 100            | -4         |

* 最左端のビットが符号を表す。符号ビットと呼ぶ。
* 絶対値が同じである正負の値を表現するビットパターンの間に簡潔な関係がある。
  * 右から読んでいくと、最初の１が現れるまでのビットが同一である。
  * その１から右のビットは、お互いに補な関係がある。

### Example: 1010を解読する

1. 1010の符号ビットは1なので、負の数である。
2. 1010を正の数に変換すると、0110である。
3. 0110の値は6である。
4. 1010は-6を表す。

### 2の補数記法による加算

* 2の補数記法による加算は、解も含めて全てのビットパターンが同じ長さである。
* 2の補数記法による加算は、通常の加算と同じように行い、左端に生成される余分なビットを切り捨てる。

#### Example: 0101 + 0010

$$
\begin{array}{r}
  0101 \\
+ 0010 \\
\hline
  0111 \\
\end{array}
$$

#### Example: 0111 + 1011

$$
\begin{array}{r}
  0111 \\
+ 1011 \\
\hline
  0010 \\
\end{array}
$$

0111 + 1011 = 10010 であるが、最左端のビットを切り捨てる。

$$
\texttt{0111}_{2} = 7_{10}
$$

$$
\texttt{1011}_{2} = -5_{10}
$$

$$
\texttt{0010}_{2} = 2_{10}
$$

### 2の補数記法による減算

$$
7 - 5 = 7 + (-5) = 2
$$

1. 7の2の補数を求める。$7 = 0111_{2}$ 
2. 5の2の補数を求める。$5 = 0101_{2}$ 
3. $-5 = 1011_{2}$ 
4. $0111_{2} + 1011_{2} = 0010_{2}$ 

### オーバーフロー

#### やってみよう

```c
#include <stdio.h>

int main() {
    char a = 127;
    char b = 1;
    char c = a + b;
    printf("a = %d, b = %d\n", a, b);
    printf("a + b = %d\n", c);
    return 0;
}
```

`char`型は8ビットで表現され、最大値は127であり、最小値は-128である。問題$127 + 1$ の結果は、`char`型の範囲を超え、$128$が得られないことになる。このような現象をオーバーフローと呼ぶ。

#### 2038年問題

[2038年問題](https://ja.wikipedia.org/wiki/2038%E5%B9%B4%E5%95%8F%E9%A1%8C)

### １６進記法

| ビットパターン | 16進数 |
| -------------- | ------ |
| 0000           | 0      |
| 0001           | 1      |
| 0010           | 2      |
| 0011           | 3      |
| 0100           | 4      |
| 0101           | 5      |
| 0110           | 6      |
| 0111           | 7      |
| 1000           | 8      |
| 1001           | 9      |
| 1010           | A      |
| 1011           | B      |
| 1100           | C      |
| 1101           | D      |
| 1110           | E      |
| 1111           | F      |

１６進記法では、４ビットのパターンを１つの記号で表現できる。

#### Example: 2進数を16進数に変換する

$$
\texttt{1011}_2 = \texttt{B}_{16}
$$

$$
\texttt{1011 0101 0011}_2 = \texttt{B53}_{16}
$$

## 小数

### 浮動小数点記法

* 符号ビット
* 指数部
* 仮数部



## 練習問題

1. 次のビットパターンを16進記法で表現せよ。
   * 0101 1010
   * 1100 0011 1010
   * 1111 0001 0100 1001
2. 次の16進数をビットパターンで表現せよ。
    * 610A
    * ABCD
    * 5F3A
    * 0100
3. $p = 1, q = 0$ のとき、次の論理式の値を求めよ。
    * $p \land q$
    * $p \lor q$
    * $\lnot p$
4. 次の10進数を2進数に変換せよ。
   1. 32
   2. 64
   3. 15
   4. 27
5. 次の2進数を10進数に変換せよ。
   1. 101010
   2. 100011
   3. 0110
   4. 11111
6. 次の２進数の和を求めよ。
   1. 101 + 110
   2. 1101 + 1011
   3. 10101 + 11011
   4. 101010 + 11011
  
### 2の補数

1. 次の２の補数表現を、それぞれ等しい10進数に変換せよ。
   1. 00011
   2. 01111
   3. 11100
   4. 11010
   5. 00000
   6. 10000
2. 次の１０進数をそれぞれ等しい8ビットパターンの２の補数表現に変換せよ。
   1. 6
   2. -6
   3. -17
   4. 13
   5. -1
   6. 0